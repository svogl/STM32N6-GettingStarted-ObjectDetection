
/* AUTOGENERATED DO NOT MODIFY */

/**
 ******************************************************************************
 * @file    stai_network.c
 * @author  SRA Artificial Intelligence & Embedded Architectures
 * @brief   Implementation of ST.AI platform public APIs for ATON
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stai_network.h"
#include "ll_aton_rt_user_api.h"
#include "ll_aton_util.h"
#include "ll_aton_version.h"

/* Status variables */
LL_ATON_DECLARE_NAMED_NN_INTERFACE(network);

/* Helper macros & functions */
#define __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_interface_ptr, ctx)                                                  \
  do                                                                                                                   \
  {                                                                                                                    \
    if ((nn_interface_ptr) != &NN_Interface_network)                                                     \
      __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((ctx), STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE);                   \
  } while (0)

static inline stai_return_code __ll_aton_stai_network_get_inputs_or_weights(stai_network *network,
                                                                                          stai_ptr *pointers,
                                                                                          stai_size *n_ptrs,
                                                                                          bool inputs)
{
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  /* check parameters */
  if (!n_ptrs)
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                STAI_ERROR_NETWORK_INVALID_API_ARGUMENTS);

  /* get input buffers */
  const LL_Buffer_InfoTypeDef *input_buffers = nn_i_ptr->input_buffers_info();

  /* copy buffer addresses */
  unsigned cnt = 0;
  if (input_buffers != NULL)
  {
    for (unsigned idx = 0; input_buffers[idx].name != NULL; idx++)
    {
      const LL_Buffer_InfoTypeDef *buffer_info = &input_buffers[idx];
      if (inputs == !buffer_info->is_param)
      {
        if (pointers)
        {
          if (buffer_info->is_user_allocated) // is it an user allocatable buffer
          {
            LL_ATON_ASSERT(buffer_info->offset_start ==
                           0); // user allocated buffers always have an offset equal to zero
            pointers[cnt] = LL_Buffer_addr_start(buffer_info); // user allocated buffers are saved with virtual address
            LL_ATON_ASSERT(((uintptr_t)pointers[cnt] % STAI_CACHE_USER_BUFFER_ALIGNMENT) == 0);
          }
          else // buffer is not user allocatable
          {
            pointers[cnt] = ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(LL_Buffer_addr_start(buffer_info));
          }
        }
        cnt++;
      }
    }
  }
  else
  {
    STAI_ASSERT((inputs ? STAI_NETWORK_IN_NUM : STAI_NETWORK_WEIGHTS_NUM) == 0);
  }
#ifndef NDEBUG
  if (inputs)
  {
    STAI_ASSERT(cnt == STAI_NETWORK_IN_NUM);
  }
  else
  {
    STAI_ASSERT(cnt == STAI_NETWORK_WEIGHTS_NUM);
  }
#endif // !NDEBUG

  /* save number of elements return value */
  if (inputs)
  {
    *n_ptrs = STAI_NETWORK_IN_NUM;
  }
  else
  {
    *n_ptrs = STAI_NETWORK_WEIGHTS_NUM;
  }

  return STAI_SUCCESS;
}

static inline stai_return_code __ll_aton_stai_network_get_outputs_or_activations(stai_network *network,
                                                                                               stai_ptr *pointers,
                                                                                               stai_size *n_ptrs,
                                                                                               bool outputs)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  /* check parameters */
  if (!n_ptrs)
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                STAI_ERROR_NETWORK_INVALID_API_ARGUMENTS);

  /* get output buffers */
  const LL_Buffer_InfoTypeDef *out_activ_buffers;
  if (outputs)
  {
    out_activ_buffers = nn_i_ptr->output_buffers_info();
  }
  else
  {
    out_activ_buffers = nn_i_ptr->internal_buffers_info();
  }

  /* copy buffer addresses */
  unsigned cnt = 0;
  if (out_activ_buffers != NULL)
  {
    for (unsigned idx = 0; out_activ_buffers[idx].name != NULL; idx++)
    {
      const LL_Buffer_InfoTypeDef *buffer_info = &out_activ_buffers[idx];
      STAI_ASSERT(!buffer_info->is_param); // may never happen
      if (pointers)
      {
        if (buffer_info->is_user_allocated) // is it a user allocatable buffer
        {
          LL_ATON_ASSERT(buffer_info->offset_start == 0); // user allocated buffers always have an offset equal to zero
          pointers[cnt] = LL_Buffer_addr_start(buffer_info); // user allocated buffers are saved with virtual address
          LL_ATON_ASSERT(((uintptr_t)pointers[cnt] % STAI_CACHE_USER_BUFFER_ALIGNMENT) == 0);
        }
        else // buffer is not user allocatable
        {
          pointers[cnt] = ATON_LIB_PHYSICAL_TO_VIRTUAL_ADDR(LL_Buffer_addr_start(buffer_info));
        }
      }
      cnt++;
    }
  }
  else
  {
    STAI_ASSERT((outputs ? STAI_NETWORK_OUT_NUM : STAI_NETWORK_ACTIVATIONS_NUM) == 0);
  }
#ifndef NDEBUG
  if (outputs)
  {
    STAI_ASSERT(cnt == STAI_NETWORK_OUT_NUM);
  }
  else
  {
    STAI_ASSERT(cnt == STAI_NETWORK_ACTIVATIONS_NUM);
  }
#endif // !NDEBUG

  /* save number of elements return value */
  if (outputs)
  {
    *n_ptrs = STAI_NETWORK_OUT_NUM;
  }
  else
  {
    *n_ptrs = STAI_NETWORK_ACTIVATIONS_NUM;
  }

  return STAI_SUCCESS;
}

static inline stai_return_code __ll_aton_stai_network_set_inputs_or_weights(stai_network *network,
                                                                                          const stai_ptr *pointers,
                                                                                          const stai_size n_ptrs,
                                                                                          bool inputs)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  /* get input buffers */
  const LL_Buffer_InfoTypeDef *input_buffers = nn_i_ptr->input_buffers_info();

  /* check values & addresses */
  LL_ATON_ASSERT(input_buffers != NULL);
  if (input_buffers && !pointers)
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                STAI_ERROR_NETWORK_INVALID_API_ARGUMENTS);

  if (inputs)
  {
    if (n_ptrs != STAI_NETWORK_IN_NUM)
      __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network, STAI_ERROR_NETWORK_INVALID_IN_NUM);
  }
  else
  {
    if (n_ptrs != STAI_NETWORK_WEIGHTS_NUM)
      __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                  STAI_ERROR_NETWORK_INVALID_WEIGHTS_NUM);
  }

  unsigned cnt = 0;
  if (input_buffers != NULL)
  {
    for (unsigned idx = 0; input_buffers[idx].name != NULL; idx++)
    {
      const LL_Buffer_InfoTypeDef *buffer_info = &input_buffers[idx];
      if (inputs == !buffer_info->is_param)
      {
        if (buffer_info->is_user_allocated) // is it an user allocatable buffer
        {
          LL_ATON_ASSERT(buffer_info->offset_start == 0); // user allocated buffers always have an offset equal to zero
          unsigned char **address_location = (unsigned char **)buffer_info->addr_base.p;
          unsigned char *new_address = pointers[cnt];

          if (((uintptr_t)new_address % STAI_CACHE_USER_BUFFER_ALIGNMENT) != 0) // check new address alignment
          {                                                                     // new address is not aligned
            __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                        STAI_ERROR_INVALID_BUFFER_ALIGNMENT);
          }
          else // new address is aligned
          {
            LL_ATON_ASSERT(address_location != NULL);
            *address_location = new_address;
          }
        }
        else // buffer is not user allocatable
        {
          if (ATON_LIB_VIRTUAL_TO_PHYSICAL_ADDR(pointers[cnt]) != LL_Buffer_addr_start(buffer_info))
            __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                        STAI_ERROR_NETWORK_INVALID_IN_PTR);
        }
        cnt++;
      }
    }
  }
  else
  {
    STAI_ASSERT((inputs ? STAI_NETWORK_IN_NUM : STAI_NETWORK_WEIGHTS_NUM) == 0);
  }
#ifndef NDEBUG
  if (inputs)
  {
    STAI_ASSERT(cnt == STAI_NETWORK_IN_NUM);
  }
  else
  {
    STAI_ASSERT(cnt == STAI_NETWORK_WEIGHTS_NUM);
  }
#endif // !NDEBUG

  return STAI_SUCCESS;
}

static inline stai_return_code __ll_aton_stai_network_set_outputs_or_activations(stai_network *network,
                                                                                               const stai_ptr *pointers,
                                                                                               const stai_size n_ptrs,
                                                                                               bool outputs)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  /* get output buffers */
  const LL_Buffer_InfoTypeDef *out_activ_buffers;
  if (outputs)
  {
    out_activ_buffers = nn_i_ptr->output_buffers_info();
  }
  else
  {
    out_activ_buffers = nn_i_ptr->output_buffers_info();
  }

  /* check values & addresses */
  if (out_activ_buffers && !pointers)
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                STAI_ERROR_NETWORK_INVALID_API_ARGUMENTS);

  if (outputs)
  {
    if (n_ptrs != STAI_NETWORK_OUT_NUM)
      __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network, STAI_ERROR_NETWORK_INVALID_OUT_NUM);
  }
  else
  {
    if (n_ptrs != STAI_NETWORK_ACTIVATIONS_NUM)
      __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network, STAI_ERROR_NETWORK_INVALID_OUT_NUM);
  }

  unsigned cnt = 0;
  if (out_activ_buffers != NULL)
  {
    for (unsigned idx = 0; out_activ_buffers[idx].name != NULL; idx++)
    {
      const LL_Buffer_InfoTypeDef *buffer_info = &out_activ_buffers[idx];
      if (buffer_info->is_user_allocated) // is it an user allocatable buffer
      {
        LL_ATON_ASSERT(buffer_info->offset_start == 0); // user allocated buffers always have an offset equal to zero
        unsigned char **address_location = (unsigned char **)buffer_info->addr_base.p;
        unsigned char *new_address = pointers[cnt];

        if (((uintptr_t)new_address % STAI_CACHE_USER_BUFFER_ALIGNMENT) != 0) // check new address alignment
        {                                                                     // new address is not aligned
          __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                      STAI_ERROR_INVALID_BUFFER_ALIGNMENT);
        }
        else // new address is aligned
        {
          LL_ATON_ASSERT(address_location != NULL);
          *address_location = new_address;
        }
      }
      else // buffer is not user allocatable
      {
        STAI_ASSERT(!buffer_info->is_param);
        if (ATON_LIB_VIRTUAL_TO_PHYSICAL_ADDR(pointers[cnt]) != LL_Buffer_addr_start(out_activ_buffers))
          __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                      STAI_ERROR_NETWORK_INVALID_OUT_PTR);
      }
      cnt++;
    }
  }
  else
  {
    STAI_ASSERT((outputs ? STAI_NETWORK_OUT_NUM : STAI_NETWORK_ACTIVATIONS_NUM) == 0);
  }
#ifndef NDEBUG
  if (outputs)
  {
    STAI_ASSERT(cnt == STAI_NETWORK_OUT_NUM);
  }
  else
  {
    STAI_ASSERT(cnt == STAI_NETWORK_ACTIVATIONS_NUM);
  }
#endif // !NDEBUG

  return STAI_SUCCESS;
}

/*****************************************************************************/
/*  Network management APIs  */
STAI_API_ENTRY
stai_return_code stai_network_init(stai_network *network)
{
  /* check context handle */
  if (!network)
    return STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE;

  _stai_aton_context *ctx = (_stai_aton_context *)network;
  if (ctx->network_instance.network != NULL) // already initialized
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN(ctx, STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE);

  ctx->network_instance.network = (const NN_Interface_TypeDef *)&NN_Interface_network;
  ctx->exec_status = STAI_SUCCESS;
  ctx->first_error = STAI_SUCCESS;

  __ll_aton_stai_init_network_instance(ctx);

  return STAI_SUCCESS;
}

STAI_API_ENTRY
stai_return_code stai_network_deinit(stai_network *network)
{
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);
  _stai_aton_context *ctx = (_stai_aton_context *)network;

  if (ctx->exec_status != STAI_DONE && ctx->exec_status != STAI_SUCCESS)
  {
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN(ctx, STAI_ERROR_NETWORK_STILL_RUNNING);
  }

  __ll_aton_stai_deinit_network_instance(ctx);

  ctx->network_instance.network = NULL;

  ctx->callback = NULL;
  ctx->callback_cookie = NULL;
  LL_ATON_RT_SetNetworkCallback(&ctx->network_instance, NULL);

  ctx->exec_status = STAI_SUCCESS;
  ctx->first_error = STAI_SUCCESS;

  return STAI_SUCCESS;
}

STAI_API_ENTRY
stai_return_code stai_network_run(stai_network *network, const stai_run_mode mode)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  return __ll_aton_stai_run(network, mode);
}

STAI_API_ENTRY
stai_return_code stai_network_train(stai_network *network, const stai_run_mode mode)
{
  LL_ATON_LIB_UNUSED(mode);

  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network, STAI_ERROR_NOT_IMPLEMENTED);
}

/*****************************************************************************/
/*  Getters APIs  */
STAI_API_ENTRY
stai_return_code stai_network_get_inputs(stai_network *network, stai_ptr *inputs, stai_size *n_inputs)
{
  return __ll_aton_stai_network_get_inputs_or_weights(network, inputs, n_inputs, true);
}

STAI_API_ENTRY
stai_return_code stai_network_get_weights(stai_network *network, stai_ptr *weights, stai_size *n_weights)
{
  return __ll_aton_stai_network_get_inputs_or_weights(network, weights, n_weights, false);
}

STAI_API_ENTRY
stai_return_code stai_network_get_outputs(stai_network *network, stai_ptr *outputs, stai_size *n_outputs)
{
  return __ll_aton_stai_network_get_outputs_or_activations(network, outputs, n_outputs, true);
}

STAI_API_ENTRY
stai_return_code stai_network_get_activations(stai_network *network, stai_ptr *activations,
                                                            stai_size *n_activations)
{
  return __ll_aton_stai_network_get_outputs_or_activations(network, activations, n_activations, false);
}

static const stai_network_info __stai_network_network_info;
STAI_API_ENTRY
stai_return_code stai_network_get_info(stai_network *network, stai_network_info *info)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  // Copy of network info struct
  *info = __stai_network_network_info;

  return STAI_SUCCESS;
}

STAI_API_ENTRY
stai_return_code stai_network_get_states(stai_network *network, stai_ptr *states, stai_size *n_states)
{
  LL_ATON_LIB_UNUSED(states);

  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  *n_states = 0;
  return STAI_SUCCESS;
}

STAI_API_ENTRY
stai_return_code stai_network_get_error(stai_network *network)
{
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);
  _stai_aton_context *ctx = (_stai_aton_context *)network;

  // return 1st generated error or STAI_SUCCESS if no errors so far
  return ctx->first_error;
}

/*****************************************************************************/
/*  Setters APIs  */
STAI_API_ENTRY
stai_return_code stai_network_set_inputs(stai_network *network, const stai_ptr *inputs,
                                                       const stai_size n_inputs)
{
  return __ll_aton_stai_network_set_inputs_or_weights(network, inputs, n_inputs, true);
}

STAI_API_ENTRY
stai_return_code stai_network_set_weights(stai_network *network, const stai_ptr *weights,
                                                        const stai_size n_weights)
{
  return __ll_aton_stai_network_set_inputs_or_weights(network, weights, n_weights, false);
}

STAI_API_ENTRY
stai_return_code stai_network_set_outputs(stai_network *network, const stai_ptr *outputs,
                                                        const stai_size n_outputs)
{
  return __ll_aton_stai_network_set_outputs_or_activations(network, outputs, n_outputs, true);
}

STAI_API_ENTRY
stai_return_code stai_network_set_activations(stai_network *network, const stai_ptr *activations,
                                                            const stai_size n_activations)
{
  return __ll_aton_stai_network_set_outputs_or_activations(network, activations, n_activations, false);
}

STAI_API_ENTRY
stai_return_code stai_network_set_states(stai_network *network, const stai_ptr *states,
                                                       const stai_size n_states)
{
  LL_ATON_LIB_UNUSED(states);

  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  if (n_states != 0)
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network, STAI_ERROR_NETWORK_INVALID_STATES_NUM);
  else
    return STAI_SUCCESS;
}

STAI_API_ENTRY
stai_return_code stai_network_set_callback(stai_network *network, const stai_event_cb cb, void *cb_cookie)
{
  if (network == NULL)
  {
    return STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE;
  }

  _stai_aton_context *nn_ctx = (_stai_aton_context *)network;

  if ((nn_ctx->network_instance.network != NULL) &&
      (nn_ctx->network_instance.network != &NN_Interface_network))
  {
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN(nn_ctx, STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE);
  }

  nn_ctx->callback = cb;
  nn_ctx->callback_cookie = cb_cookie;

  LL_ATON_RT_SetNetworkCallback(&nn_ctx->network_instance,
                                (cb != NULL) ? _stai_aton_internal_epoch_block_callback : NULL);

  return STAI_SUCCESS;
}

/***************************************************************************/
/*  Extended ATON Target Specific APIs  */
STAI_API_ENTRY
stai_return_code stai_ext_network_run_continue(stai_network *network)
{
  _stai_aton_context *nn_ctx = (_stai_aton_context *)network;
  if (nn_ctx == NULL)
  {
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN((_stai_aton_context *)network,
                                                STAI_ERROR_NETWORK_INVALID_CONTEXT_HANDLE);
  }

  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, nn_ctx);

  if (nn_ctx->network_instance.exec_state.current_epoch_block == NULL)
  {
    __LL_ATON_STAI_SET_1ST_CTX_ERROR_AND_RETURN(nn_ctx, STAI_ERROR_NETWORK_INVALID_API_ARGUMENTS);
  }

  __LL_ATON_START_CONT_EXEC(&nn_ctx->network_instance);
}

STAI_API_ENTRY
stai_return_code stai_ext_network_get_nn_run_status(stai_network *network)
{
  /* check context & network interface handle */
  __LL_ATON_STAI_ACQUIRE_INTERFACE(nn_i_ptr, network);
  __LL_ATON_STAI_CHECK_NETWORK_INTERFACE(nn_i_ptr, (_stai_aton_context *)network);

  /* get current execution status */
  STAI_ASSERT(network != NULL);
  _stai_aton_context *stai_nn_ctx =
      (_stai_aton_context *)((void *)network) - offsetof(_stai_aton_context, network_instance);
  stai_return_code current_exec_status = __ll_aton_stai_get_execution_status(stai_nn_ctx);

  return current_exec_status;
}

STAI_API_ENTRY
stai_return_code stai_ext_network_new_inference(stai_network *network)
{
  return __ll_aton_stai_reset(network);
}

// clang-format off
/***************************************************************************/
/*  Auto-generated network information structure  */
static const stai_network_info __stai_network_network_info = {
    // Still missing fields are:
    // - `.model_signature = STAI_NETWORK_SIGNATURE`,     // TODO: generate this macro in `*.h` file
    // - `.c_model_signature = STAI_NETWORK_C_SIGNATURE`, // TODO: generate this macro in `*.h` file
    // - `.n_macc =` ???,

    .c_model_name = STAI_NETWORK_C_MODEL_NAME,
    .c_compile_datetime = __DATE__ " " __TIME__,

    .runtime_version = STAI_INIT_VERSION(LL_ATON_VERSION_MAJOR, LL_ATON_VERSION_MINOR, LL_ATON_VERSION_MICRO),
    .tool_version = STAI_INIT_VERSION(STAI_TOOLS_VERSION_MAJOR, STAI_TOOLS_VERSION_MINOR, STAI_TOOLS_VERSION_MICRO),
    .api_version = STAI_INIT_VERSION(STAI_API_VERSION_MAJOR, STAI_API_VERSION_MINOR, STAI_API_VERSION_MICRO),

    .flags = STAI_NETWORK_FLAGS,

    .n_inputs = STAI_NETWORK_IN_NUM, 
    .n_outputs = STAI_NETWORK_OUT_NUM,
    .n_activations = STAI_NETWORK_ACTIVATIONS_NUM, 
    .n_weights = STAI_NETWORK_WEIGHTS_NUM,
    .n_states = STAI_NETWORK_STATES_NUM,

    .c_model_datetime = "2025-12-23 16:48:52",

    .n_nodes = 49,

    .inputs = (stai_tensor[STAI_NETWORK_IN_NUM]) {
      STAI_INIT_TENSOR(
        STAI_NETWORK_IN_1_NAME,
        STAI_NETWORK_IN_1_FLAGS,
        STAI_NETWORK_IN_1_FORMAT,
        STAI_NETWORK_IN_1_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_IN_1_RANK, STAI_NETWORK_IN_1_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_IN_1_SCALE_OFFSET_NUM, STAI_NETWORK_IN_1_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_IN_1_SCALE_OFFSET_NUM, STAI_NETWORK_IN_1_OFFSETS)
        ),
    },
    .outputs = (stai_tensor[STAI_NETWORK_OUT_NUM]) {
      STAI_INIT_TENSOR(
        STAI_NETWORK_OUT_1_NAME,
        STAI_NETWORK_OUT_1_FLAGS,
        STAI_NETWORK_OUT_1_FORMAT,
        STAI_NETWORK_OUT_1_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_OUT_1_RANK, STAI_NETWORK_OUT_1_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_OUT_1_SCALE_OFFSET_NUM, STAI_NETWORK_OUT_1_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_OUT_1_SCALE_OFFSET_NUM, STAI_NETWORK_OUT_1_OFFSETS)
        ),
    },
    .activations = (stai_tensor[STAI_NETWORK_ACTIVATIONS_NUM]) {
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_1_NAME,
        STAI_NETWORK_ACTIVATIONS_1_FLAGS,
        STAI_NETWORK_ACTIVATIONS_1_FORMAT,
        STAI_NETWORK_ACTIVATIONS_1_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_1_RANK, STAI_NETWORK_ACTIVATIONS_1_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_1_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_1_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_1_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_1_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_2_NAME,
        STAI_NETWORK_ACTIVATIONS_2_FLAGS,
        STAI_NETWORK_ACTIVATIONS_2_FORMAT,
        STAI_NETWORK_ACTIVATIONS_2_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_2_RANK, STAI_NETWORK_ACTIVATIONS_2_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_2_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_2_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_2_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_2_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_3_NAME,
        STAI_NETWORK_ACTIVATIONS_3_FLAGS,
        STAI_NETWORK_ACTIVATIONS_3_FORMAT,
        STAI_NETWORK_ACTIVATIONS_3_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_3_RANK, STAI_NETWORK_ACTIVATIONS_3_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_3_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_3_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_3_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_3_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_4_NAME,
        STAI_NETWORK_ACTIVATIONS_4_FLAGS,
        STAI_NETWORK_ACTIVATIONS_4_FORMAT,
        STAI_NETWORK_ACTIVATIONS_4_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_4_RANK, STAI_NETWORK_ACTIVATIONS_4_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_4_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_4_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_4_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_4_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_5_NAME,
        STAI_NETWORK_ACTIVATIONS_5_FLAGS,
        STAI_NETWORK_ACTIVATIONS_5_FORMAT,
        STAI_NETWORK_ACTIVATIONS_5_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_5_RANK, STAI_NETWORK_ACTIVATIONS_5_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_5_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_5_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_5_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_5_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_6_NAME,
        STAI_NETWORK_ACTIVATIONS_6_FLAGS,
        STAI_NETWORK_ACTIVATIONS_6_FORMAT,
        STAI_NETWORK_ACTIVATIONS_6_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_6_RANK, STAI_NETWORK_ACTIVATIONS_6_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_7_NAME,
        STAI_NETWORK_ACTIVATIONS_7_FLAGS,
        STAI_NETWORK_ACTIVATIONS_7_FORMAT,
        STAI_NETWORK_ACTIVATIONS_7_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_7_RANK, STAI_NETWORK_ACTIVATIONS_7_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_7_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_7_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_7_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_7_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_8_NAME,
        STAI_NETWORK_ACTIVATIONS_8_FLAGS,
        STAI_NETWORK_ACTIVATIONS_8_FORMAT,
        STAI_NETWORK_ACTIVATIONS_8_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_8_RANK, STAI_NETWORK_ACTIVATIONS_8_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_9_NAME,
        STAI_NETWORK_ACTIVATIONS_9_FLAGS,
        STAI_NETWORK_ACTIVATIONS_9_FORMAT,
        STAI_NETWORK_ACTIVATIONS_9_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_9_RANK, STAI_NETWORK_ACTIVATIONS_9_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_9_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_9_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_9_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_9_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_10_NAME,
        STAI_NETWORK_ACTIVATIONS_10_FLAGS,
        STAI_NETWORK_ACTIVATIONS_10_FORMAT,
        STAI_NETWORK_ACTIVATIONS_10_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_10_RANK, STAI_NETWORK_ACTIVATIONS_10_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_11_NAME,
        STAI_NETWORK_ACTIVATIONS_11_FLAGS,
        STAI_NETWORK_ACTIVATIONS_11_FORMAT,
        STAI_NETWORK_ACTIVATIONS_11_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_11_RANK, STAI_NETWORK_ACTIVATIONS_11_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_11_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_11_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_11_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_11_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_12_NAME,
        STAI_NETWORK_ACTIVATIONS_12_FLAGS,
        STAI_NETWORK_ACTIVATIONS_12_FORMAT,
        STAI_NETWORK_ACTIVATIONS_12_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_12_RANK, STAI_NETWORK_ACTIVATIONS_12_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_12_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_12_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_12_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_12_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_13_NAME,
        STAI_NETWORK_ACTIVATIONS_13_FLAGS,
        STAI_NETWORK_ACTIVATIONS_13_FORMAT,
        STAI_NETWORK_ACTIVATIONS_13_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_13_RANK, STAI_NETWORK_ACTIVATIONS_13_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_14_NAME,
        STAI_NETWORK_ACTIVATIONS_14_FLAGS,
        STAI_NETWORK_ACTIVATIONS_14_FORMAT,
        STAI_NETWORK_ACTIVATIONS_14_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_14_RANK, STAI_NETWORK_ACTIVATIONS_14_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_14_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_14_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_14_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_14_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_15_NAME,
        STAI_NETWORK_ACTIVATIONS_15_FLAGS,
        STAI_NETWORK_ACTIVATIONS_15_FORMAT,
        STAI_NETWORK_ACTIVATIONS_15_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_15_RANK, STAI_NETWORK_ACTIVATIONS_15_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_16_NAME,
        STAI_NETWORK_ACTIVATIONS_16_FLAGS,
        STAI_NETWORK_ACTIVATIONS_16_FORMAT,
        STAI_NETWORK_ACTIVATIONS_16_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_16_RANK, STAI_NETWORK_ACTIVATIONS_16_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_16_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_16_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_16_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_16_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_17_NAME,
        STAI_NETWORK_ACTIVATIONS_17_FLAGS,
        STAI_NETWORK_ACTIVATIONS_17_FORMAT,
        STAI_NETWORK_ACTIVATIONS_17_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_17_RANK, STAI_NETWORK_ACTIVATIONS_17_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_ACTIVATIONS_18_NAME,
        STAI_NETWORK_ACTIVATIONS_18_FLAGS,
        STAI_NETWORK_ACTIVATIONS_18_FORMAT,
        STAI_NETWORK_ACTIVATIONS_18_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_ACTIVATIONS_18_RANK, STAI_NETWORK_ACTIVATIONS_18_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_ACTIVATIONS_18_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_18_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_ACTIVATIONS_18_SCALE_OFFSET_NUM, STAI_NETWORK_ACTIVATIONS_18_OFFSETS)
        ),
    },
#if LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
    .weights = (stai_tensor[STAI_NETWORK_WEIGHTS_NUM]) {
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_1_NAME,
        STAI_NETWORK_WEIGHTS_1_FLAGS,
        STAI_NETWORK_WEIGHTS_1_FORMAT,
        STAI_NETWORK_WEIGHTS_1_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_1_RANK, STAI_NETWORK_WEIGHTS_1_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_1_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_1_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_1_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_1_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_2_NAME,
        STAI_NETWORK_WEIGHTS_2_FLAGS,
        STAI_NETWORK_WEIGHTS_2_FORMAT,
        STAI_NETWORK_WEIGHTS_2_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_2_RANK, STAI_NETWORK_WEIGHTS_2_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_2_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_2_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_2_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_2_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_3_NAME,
        STAI_NETWORK_WEIGHTS_3_FLAGS,
        STAI_NETWORK_WEIGHTS_3_FORMAT,
        STAI_NETWORK_WEIGHTS_3_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_3_RANK, STAI_NETWORK_WEIGHTS_3_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_3_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_3_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_3_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_3_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_4_NAME,
        STAI_NETWORK_WEIGHTS_4_FLAGS,
        STAI_NETWORK_WEIGHTS_4_FORMAT,
        STAI_NETWORK_WEIGHTS_4_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_4_RANK, STAI_NETWORK_WEIGHTS_4_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_4_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_4_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_4_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_4_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_5_NAME,
        STAI_NETWORK_WEIGHTS_5_FLAGS,
        STAI_NETWORK_WEIGHTS_5_FORMAT,
        STAI_NETWORK_WEIGHTS_5_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_5_RANK, STAI_NETWORK_WEIGHTS_5_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_5_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_5_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_5_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_5_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_6_NAME,
        STAI_NETWORK_WEIGHTS_6_FLAGS,
        STAI_NETWORK_WEIGHTS_6_FORMAT,
        STAI_NETWORK_WEIGHTS_6_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_6_RANK, STAI_NETWORK_WEIGHTS_6_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_6_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_6_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_6_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_6_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_7_NAME,
        STAI_NETWORK_WEIGHTS_7_FLAGS,
        STAI_NETWORK_WEIGHTS_7_FORMAT,
        STAI_NETWORK_WEIGHTS_7_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_7_RANK, STAI_NETWORK_WEIGHTS_7_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_7_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_7_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_7_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_7_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_8_NAME,
        STAI_NETWORK_WEIGHTS_8_FLAGS,
        STAI_NETWORK_WEIGHTS_8_FORMAT,
        STAI_NETWORK_WEIGHTS_8_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_8_RANK, STAI_NETWORK_WEIGHTS_8_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_8_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_8_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_8_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_8_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_9_NAME,
        STAI_NETWORK_WEIGHTS_9_FLAGS,
        STAI_NETWORK_WEIGHTS_9_FORMAT,
        STAI_NETWORK_WEIGHTS_9_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_9_RANK, STAI_NETWORK_WEIGHTS_9_SHAPE),
        STAI_DECLARE_ARRAY(float, STAI_NETWORK_WEIGHTS_9_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_9_SCALES),
        STAI_DECLARE_ARRAY(int16_t, STAI_NETWORK_WEIGHTS_9_SCALE_OFFSET_NUM, STAI_NETWORK_WEIGHTS_9_OFFSETS)
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_10_NAME,
        STAI_NETWORK_WEIGHTS_10_FLAGS,
        STAI_NETWORK_WEIGHTS_10_FORMAT,
        STAI_NETWORK_WEIGHTS_10_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_10_RANK, STAI_NETWORK_WEIGHTS_10_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_11_NAME,
        STAI_NETWORK_WEIGHTS_11_FLAGS,
        STAI_NETWORK_WEIGHTS_11_FORMAT,
        STAI_NETWORK_WEIGHTS_11_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_11_RANK, STAI_NETWORK_WEIGHTS_11_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
      STAI_INIT_TENSOR(
        STAI_NETWORK_WEIGHTS_12_NAME,
        STAI_NETWORK_WEIGHTS_12_FLAGS,
        STAI_NETWORK_WEIGHTS_12_FORMAT,
        STAI_NETWORK_WEIGHTS_12_SIZE_BYTES,
        STAI_DECLARE_ARRAY(int32_t, STAI_NETWORK_WEIGHTS_12_RANK, STAI_NETWORK_WEIGHTS_12_SHAPE),
        STAI_EMPTY_ARRAY(),
        STAI_EMPTY_ARRAY()
        ),
    },
#endif // LL_ATON_DBG_BUFFER_INFO_EXCLUDED == 0
};

